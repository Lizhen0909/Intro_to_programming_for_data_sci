[
  {
    "objectID": "classes.html",
    "href": "classes.html",
    "title": "7  Object-Oriented Programming",
    "section": "",
    "text": "7.1 Classes\nPython is a versatile programming language that supports object-oriented programming (OOP). In Python, everything is an object, and built-in data types are implemented as classes.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "classes.html#classes",
    "href": "classes.html#classes",
    "title": "7  Object-Oriented Programming",
    "section": "",
    "text": "7.1.1 Built-in Data Types in Python\nIn Python, every built-in data type is implemented as a class. This includes:\n\nint\nfloat\nstr\nlist\ntuple\ndict\nset\nNoneType\n\nYou can confirm this by using the type() function or checking an object’s __class__ attribute:\n\nprint(type(42))         \nprint(type(3.14))        \nprint(type(\"hello\"))     \nprint(type([1, 2, 3]))   \nprint(type(None))       \n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'list'&gt;\n&lt;class 'NoneType'&gt;\n\n\n\n# Checking the __class__ attribute\nx = 42\nprint(x.__class__)   \n\n&lt;class 'int'&gt;\n\n\n\n\n7.1.2 Understanding Classes in Python\nA class is a blueprint for creating objects. It defines the attributes (characteristics) and methods (behaviors) that its objects will have.\nFor example, consider a Cat class: - Attributes: Characteristics shared by all cats, such as breed, fur_color, and age. - Methods: Actions that a cat can perform, such as meow(), run(), or sleep().\nFor more details, refer to the official Python documentation on classes.\n\n\n7.1.3 Creating your own classes\nUntil now, we have worked with built-in Python classes like int, list, and dict. However, in many cases, we need to create our own classes to model real-world entities in a structured way.\nDefining your own classes provides several key benefits in programming:\n\nEncapsulation – Organize data and related functionality together.\nReusability – Code can be reused by creating multiple instances of the class.\nAbstraction – Hide unnecessary details and expose only the required functionality.\nInheritance – Reuse existing class behavior in new classes, avoiding redundancy.\n\nWhen we create a new class, we actually create a new type. Now, we are going to create our own type, which we can use in a way that is similar to the built-in types.\nLet’s start with the Car class:\n\nclass Car:\n    def __init__(self, brand, color, speed=0):\n        self.brand = brand      # Attribute\n        self.color = color      # Attribute\n        self.speed = speed      # Attribute\n\n    def accelerate(self, increment):\n        \"\"\"Increase the car's speed.\"\"\"\n        self.speed += increment\n        return f\"{self.brand} is now moving at {self.speed} mph.\"\n\n    def brake(self, decrement):\n        \"\"\"Decrease the car's speed.\"\"\"\n        self.speed = max(0, self.speed - decrement)\n        return f\"{self.brand} slowed down to {self.speed} mph.\"\n\nWe’ll use the example above to explain the following terms:\n\nThe class statement: We use the class statement to create a class. The Python style guide recommends to use CamelCase for class names.\nThe constructor (or the __init__() method): A class typically has a method called __init__. This method is called a constructor and is automatically called when an object or instance of the class is created. The constructor initializes the attributes of the class. In the above example, the constructor accepts Three values as arguments, and initializes its attributes brand and color with those values and have a default value for speed.\nThe self argument: This is the first parameter of instance methods in a class. It represents the instance of the class itself, allowing access to its attributes and methods. When referring to instance attributes or methods within the class, they must be prefixed with self. The purpose of self is to distinguish instance-specific attributes and methods from local variables or other functions in the program.\n\nThis example demonstrates how a class encapsulates attributes and behaviors. The Car class defines three attributes: brand, color, and speed, along with a constructor (__init__()) and two methods: accelerate() and brake(). This structure makes it easy to create multiple car objects and manipulate their states independently.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "classes.html#objects",
    "href": "classes.html#objects",
    "title": "7  Object-Oriented Programming",
    "section": "7.2 Objects",
    "text": "7.2 Objects\nIn Python, an object is an instance of a class. A class acts as a blueprint, defining the structure and behavior that its objects will have. Each object has its own attributes (data) and can perform methods (functions associated with the class). Compared to the class (which is just a blueprint), an object is a concrete and tangible entity that exists in memory.\nIn Python, when you create a variable and assign a value to it, Python internally creates an instance of the corresponding class. Every value in Python is an object,\n\nx = 10    # x ia an insance of int class\ny = \"Hello\"     # y is an instance of str class\nz = [1, 2, 3]  # z is an instance of list class\n\nprint(type(x)) \nprint(type(y))  \nprint(type(z))  \n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'list'&gt;\n\n\nOnce we define a class as a blueprint, we can create instances of that class to generate objects of its type. In fact, we can create as many objects as we want from a single class, each with its own unique data while sharing the same structure and behavior defined in the class.\nLet’s create two objects of the Car class we defined earlier\nTo create an object or instance of the class Car, we’ll use the class name with the values to be passed as argument to the constructor for initializing the object / instance.\n\n# Creating objects (instances of the Car class)\ncar1 = Car(\"Toyota\", \"Red\")\ncar2 = Car(\"Honda\", \"Blue\")\n\nprint(type(car1))\nprint(type(car2))\n\n&lt;class '__main__.Car'&gt;\n&lt;class '__main__.Car'&gt;\n\n\n\nInstance: An instance is a specific realization of the object of a particular class. Creating an instance of a class is called Instantiation. Here a particular car is an instance of the class Car. Similarly, in the example above, the object x is an instance of the class integer. The words object and instance are often used interchangeably.\n\nThe attributes of an instance can be accessed using the . operator with the object name\n\nprint(car1.brand)\nprint(car2.brand)\nprint(car1.color)\nprint(car2.color)\nprint(car1.speed)\nprint(car2.speed)\n\nToyota\nHonda\nRed\nBlue\n0\n0\n\n\nWhat happens if the instance variable doesn’t exist?\n\ncar1.engine\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 car1.engine\n\nAttributeError: 'Car' object has no attribute 'engine'\n\n\n\nMethods are functions inside a class that operate on instance attributes. To call a method use:\n\nprint(car1.accelerate(20))\nprint(car2.brake(10))\n\nToyota is now moving at 20 mph.\nHonda slowed down to 0 mph.\n\n\nUnlike attributes, methods require parentheses () because they need to be executed, just like the functions we learned earlier\nA list of all attributes and methods associated with an object can be obtained with the dir() function. Ignore the ones with underscores - these are used by Python itself. The rest of them can be used to perform operations.\n\ndir(car1)\n\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getstate__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'accelerate',\n 'brake',\n 'brand',\n 'color',\n 'speed']\n\n\nFiltering out only user-defined attributes and methods\n\nprint([attr for attr in dir(car1) if not attr.startswith('__')])\n\n['accelerate', 'brake', 'brand', 'color', 'speed']\n\n\n\n7.2.1 Example: A class that analyzes a string\nLet us create a class that analyzes a string.\n\nclass AnalyzeString:\n    \n    #Constructor\n    def __init__(self, s):\n        s = s.lower()\n        self.words = s.split()\n    \n    #This method counts the numebr of words\n    def number_of_words(self):\n        return (len(self.words))\n    \n    #This method counts the number of words starting with the string s\n    def starts_with(self,s):\n        return len([x for x in self.words if x[:len(s)]==s])\n    \n    #This method counts the number of words of length n\n    def words_with_length(self,n):\n        return len([x for x in self.words if len(x)==n])\n    \n    #This method returns the frequency of the word w\n    def word_frequency(self,w):\n        return self.words.count(w)\n\nLet us create an instance of the class AnalyzeString() to analyze a sentence.\n\n#Defining a string\nsentence = 'This sentence in an example of a string that we will analyse using a class we have defined'\n\n\n#Creating an instance of class AnalyzeString()\nsentence_analysis = AnalyzeString(sentence)\n\n\n#The attribute 'word' contains the list of words in the sentence\nsentence_analysis.words\n\n['this',\n 'sentence',\n 'in',\n 'an',\n 'example',\n 'of',\n 'a',\n 'string',\n 'that',\n 'we',\n 'will',\n 'analyse',\n 'using',\n 'a',\n 'class',\n 'we',\n 'have',\n 'defined']\n\n\n\n#The method 'word_frequncy()' provides the frequency of a word in the sentence\nsentence_analysis.word_frequency('we')\n\n2\n\n\n\n#The method 'starts_with()' provides the frequency of number of words starting with a particular string\nsentence_analysis.starts_with('th')\n\n2\n\n\n\n\n7.2.2 Practice exercise 1\nWrite a class called PasswordManager. The class should have a list called old_passwords that holds all of the user’s past passwords. The last item of the list is the user’s current password. There should be a method called get_password that returns the current password and a method called set_password that sets the user’s password. The set_password method should only change the password if the attempted password is different from all the user’s past passwords. It should either print ‘Password changed successfully!’, or ‘Old password cannot be reused, try again.’ Finally, create a method called is_correct that receives a string and returns a boolean True or False depending on whether the string is equal to the current password or not.\nTo initialize the object of the class, use the list below.\nAfter defining the class:\n\nCheck the attribute old_passwords\nCheck the method get_password()\nTry re-setting the password to ‘ibiza1972’, and then check the current password.\nTry re-setting the password to ‘oktoberfest2022’, and then check the current password.\nCheck the is_correct() method\n\n\npast_passwords = ['titanic1911','ibiza1972','montecarlo799']\n\n\nclass PasswordManager:\n    def __init__(self,past_passwords):\n        self.old_passwords = past_passwords\n        \n    def get_password(self):\n        return self.old_passwords[len(self.old_passwords)-1]\n    \n    def set_password(self,new_password):\n        if new_password not in self.old_passwords:\n            self.old_passwords.append(new_password)\n            print(\"Password changed!\")\n        else:\n            print(\"Old password cannot be reused, try again.\")\n            \n    def is_correct(self,password):\n        if password == self.old_passwords[len(self.old_passwords)-1]:\n            return True\n        return False\n\npasswd = PasswordManager(past_passwords)",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "classes.html#class-constructors",
    "href": "classes.html#class-constructors",
    "title": "7  Object-Oriented Programming",
    "section": "7.3 Class Constructors",
    "text": "7.3 Class Constructors\nA constructor is a special method in a class that is automatically called when an object is created.\n- In Python, the constructor method is named __init__().\n- It initializes object attributes when an instance is created.\n\nclass Car:\n    def __init__(self, brand, color, speed=0):\n        \"\"\"Constructor to initialize Car attributes\"\"\"\n        self.brand = brand\n        self.color = color\n        self.speed = speed  # Default value is 0\n\n# Creating instances (objects)\ncar1 = Car(\"Toyota\", \"Red\", 50)\ncar2 = Car(\"Honda\", \"Blue\")  # speed uses default value\n\n# Accessing attributes\nprint(car1.brand, car1.color, car1.speed)  # Toyota Red 50\nprint(car2.brand, car2.color, car2.speed)\n\nToyota Red 50\nHonda Blue 0\n\n\n\n7.3.1 Default Constructor (No Parameters)\nIf a class does not explicitly define a constructor, Python automatically provides a default constructor. This constructor only includes self and takes no additional parameters.\nLet’s create an empty class to demonstrate this:\n\n# Define a class Circle that doesn't have any attributes or methods\nclass Circle:\n    pass\n\n# Create an instance of the Circle class\nc = Circle()\nprint(type(c))  \n\n&lt;class '__main__.Circle'&gt;\n\n\n\n\n7.3.2 Using Default Values in Constructors\nYou can set default values for parameters to make them optional.\n\nclass Student:\n    def __init__(self, name, grade=\"Not Assigned\"):\n        self.name = name\n        self.grade = grade  # Default: \"Not Assigned\"\n\ns1 = Student(\"John\", \"A\")  # Assigned grade\ns2 = Student(\"Emma\")       # Uses default grade\n\nprint(s1.name, s1.grade)  # John A\nprint(s2.name, s2.grade)  # Emma Not Assigned\n\nJohn A\nEmma Not Assigned",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "classes.html#difference-between-instance-attributes-and-class-attributes-in-python-oop",
    "href": "classes.html#difference-between-instance-attributes-and-class-attributes-in-python-oop",
    "title": "7  Object-Oriented Programming",
    "section": "7.4 Difference Between Instance Attributes and Class Attributes in Python (OOP)",
    "text": "7.4 Difference Between Instance Attributes and Class Attributes in Python (OOP)\nIn Python object-oriented programming, attributes can be defined at two levels:\n\nInstance Attributes → Specific to each instance of the class.\nClass Attributes → Shared across all instances of the class.\n\n\n7.4.1 Instance Attributes (Defined in __init__)\n\nDefined inside the constructor (__init__) using self, and accessed using self.attribute_name\nEach instance has its own copy of instance attributes.\nChanges to an instance attribute affect only that instance.\n\n\n# Example: Instance attributes using our Car class\n\nclass Car:\n    def __init__(self, brand, color):\n        self.brand = brand  # Instance attribute\n        self.color = color  # Instance attribute\n\n# Creating instances\ncar1 = Car(\"Toyota\", \"Red\")\ncar2 = Car(\"Honda\", \"Blue\")\n\n# Each instance has different values\nprint(car1.brand)  # Toyota\nprint(car2.brand)  # Honda\n\n# Changing an instance attribute only affects that instance\ncar1.color = \"Black\"\nprint(car1.color)  # Black\nprint(car2.color)\n\nToyota\nHonda\nBlack\nBlue\n\n\n\n\n7.4.2 Class Attributes ( Defined Outside __init__)\n\nDefined at the class level (outside __init__).\nShared across all instances of the class.\nChanging a class attribute affects all instances (unless overridden at the instance level).\n\n\nclass Car:\n    wheels = 4  # Class attribute (shared by all instances)\n    \n    def __init__(self, brand):\n        self.brand = brand  # Instance attribute\n\n# Creating instances\ncar1 = Car(\"Toyota\")\ncar2 = Car(\"Honda\")\n\n# Accessing class attribute\nprint(car1.wheels)  # 4\nprint(car2.wheels)  # 4\n\n# Changing the class attribute affects all instances\nCar.wheels = 6\nprint(car1.wheels)  # 6\nprint(car2.wheels)  # 6\n\n4\n4\n6\n6\n\n\nNote: Just like attributes, methods can be categorized into instance methods and class methods. So far, everything we have defined are instance methods. Class methods, however, are beyond the scope of this data science course and will not be covered.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "classes.html#inheritance-in-python",
    "href": "classes.html#inheritance-in-python",
    "title": "7  Object-Oriented Programming",
    "section": "7.5 Inheritance in Python",
    "text": "7.5 Inheritance in Python\n\n7.5.1 What is Inheritance?\nInheritance is a fundamental concept in Object-Oriented Programming (OOP) that allows a child class to inherit attributes and methods from a parent class. This promotes code reuse and hierarchical structuring of classes.\nHere are Key Benefits of Inheritance:\n\nCode Reusability – Avoids redundant code by reusing existing functionality.\nExtensibility – Allows adding new functionality without modifying the original class.\nImproves Maintainability – Easier to manage and update related classes.\n\n\n\n7.5.2 Defining a Parent (Base) and Child (Derived) Class\nA child class inherits from a parent class by specifying the parent class name in parentheses.\nExample: Basic Inheritance\n\n# Parent Class (Base Class)\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        return \"Some sound\"\n\n# Child Class (Derived Class)\nclass Dog(Animal):  # Inheriting from Animal\n    def speak(self):\n        return \"Woof!\"\n\n# Creating objects\ndog1 = Dog(\"Buddy\")\n\n# Accessing inherited attributes and methods\nprint(dog1.name)      \nprint(dog1.speak())   \n\nBuddy\nWoof!\n\n\nExplanation:\n\nDog inherits from Animal, meaning it gets all the properties of Animal.\nThe Dog class overrides the speak() method to provide a specialized behavior.\n\n\n\n7.5.3 The super() Function\nThe super() function allows calling methods from the parent class inside the child class.\nExample: Using super() to Extend Parent Behavior\n\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        return \"Some sound\"\n\nclass Cat(Animal):\n    def __init__(self, name, color):\n        super().__init__(name)  # Calling Parent Constructor\n        self.color = color  # Additional attribute in Child Class\n\n    def speak(self):\n        return \"Meow!\"\n\n# Creating an instance\ncat1 = Cat(\"Whiskers\", \"Gray\")\n\nprint(cat1.name)   # Whiskers (Inherited from Animal)\nprint(cat1.color)  # Gray (Defined in Cat)\nprint(cat1.speak()) # Meow! (Overridden method)\n\nWhiskers\nGray\nMeow!\n\n\n\nsuper().__init__(name) ensures the parent class constructor is properly called.\nThis allows the child class to initialize both inherited and new attributes.\n\n\n\n7.5.4 Method Overriding in Inheritance\n\nIf a method exists in both the parent and child class, the child class’s method overrides the parent’s method.\nThis is useful for customizing behavior.\n\nExample: Overriding a Method\n\nclass Parent:\n    def show(self):\n        return \"This is the Parent class\"\n\nclass Child(Parent):\n    def show(self):  # Overriding method\n        return \"This is the Child class\"\n\nobj = Child()\nprint(obj.show())  # This is the Child class\n\nThis is the Child class\n\n\n\n\n7.5.5 Check Relationship\n\nissubclass(Child, Parent) → Checks if a class is a subclass of another.\nisinstance(object, Class) → Checks if an object is an instance of a class.\n\n\nclass Animal:\n    pass\n\nclass Dog(Animal):\n    pass\n\ndog1 = Dog()\n\nprint(issubclass(Dog, Animal))  # True\nprint(isinstance(dog1, Dog))    # True\nprint(isinstance(dog1, Animal)) # True (Since Dog inherits from Animal)\n\nTrue\nTrue\nTrue\n\n\n\n\n7.5.6 The object class in Python\nWhen you define a class in Python without explicitly specifying a parent class, Python automatically makes it inherit from the built-in object class.\nLet’s confirm this using the issubclss() method\n\nprint(issubclass(Car, object))\n\nTrue\n\n\nYou can use the __bases__ attribute to check the parent class(es):\n\nprint(Car.__bases__) \n\n(&lt;class 'object'&gt;,)\n\n\n\n7.5.6.1 What is the object class?\n\nobject is the base class for all classes in Python.\nIt provides default methods like:\n\nstr()\nrepr()\neq()\ninit()\nAnd more…\n\n\nLet’s back to the whole list of car1\n\ndir(car1)\n\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getstate__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'brand',\n 'wheels']\n\n\nMany special methods and attributes that start with double underscores (__) are inherited from the object class in Python. These are known as dunder (double underscore) methods or magic methods, such as __init__(), __str__(), and __eq__(). These methods are automatically called by Python for specific operations, and users typically do not need to call them directly.\nWe generally do not recommend modifying these methods unless you are customizing class behavior (e.g., overloading operators). If you need to define private attributes or methods, use a single underscore _ (convention) or double underscore __ (name mangling) to prevent accidental access.\nKey Takeaways:\n\nInheritance promotes code reuse and hierarchy in OOP.\nA child class can inherit and override parent class methods.\nUse super() to call parent class methods inside the child class.\n\nFor more details, refer to the official Python documentation on Inheritance.\n\n\n\n7.5.7 Practice exercise 2\nDefine a class that inherits the in-built Python class list, and adds a new method to the class called nunique() which returns the number of unique elements in the list.\nDefine the following list as an object of the class you created. Then:\n\nFind the number of unique elements in the object using the method nunique() of the inherited class.\nCheck if the pop() method of the parent class works to pop an element out of the object.\n\n\nlist_ex = [1,2,5,3,6,5,5,5,12]\n\n\nclass list_v2(list):\n    def nuinque(self):\n        unique_elements = []\n        for x in self:\n            if x not in unique_elements:\n                unique_elements.append(x)\n        return len(unique_elements)\n    \nlist_ex = list_v2(list_ex)\nprint(\"Number of unique elements = \", list_ex.nuinque())\nprint(\"Checking the pop() method, the popped out element is\", list_ex.pop())\n\nNumber of unique elements =  6\nChecking the pop() method, the popped out element is 12\n\n\n\n\n7.5.8 Practice exercise 3\nDefine a class named PasswordManagerUpdated that inherits the class PasswordManager defined in Practice exercise 1. The class PasswordManagerUpdated should have two methods, other than the constructor:\n\nThe method set_password() that sets a new password. The new password must only be accepted if it does not have any punctuations in it, and if it is not the same as one of the old passwords. If the new password is not acceptable, then one of the appropriate messages should be printed - (a) Cannot have punctuation in password, try again, or (b) Old password cannot be reused, try again.\nThe method suggest_password() that randomly sets and returns a password as a string comprising of 15 randomly chosen letters. Letters may be repeated as well.\n\n\nfrom string import punctuation\nimport random as rm\nimport string as st\nclass PasswordManager_updated(PasswordManager):\n    def __init__(self,past_passwords):\n        self.old_passwords = past_passwords.copy()\n    \n    def set_password(self,new_password):\n        if new_password not in self.old_passwords:\n            for punc in punctuation:\n                if punc in new_password:\n                    print(\"Cannot have punctuation in password, try again\")\n                    break\n            self.old_passwords.append(new_password)\n            print(\"password changed!\")\n        else:\n            print(\"Old password cannot be reused, try again.\")\n            \n    def suggest_password(self):\n        suggested_passwd = ''\n        for i in range(15):\n            suggested_passwd = suggested_passwd + st.ascii_lowercase[rm.randint(0,26)]\n        self.old_passwords.append(suggested_passwd)           \n        return suggested_passwd",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  }
]