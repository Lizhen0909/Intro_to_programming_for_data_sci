---
title: "R: Objects"
format:
    html:
      toc: true
      self-contained: true
editor_options: 
  chunk_output_type: console
---
  
## Atomic vectors
  
An atomic vector in R is a vector containing objects of the same datatype. If the objects are not of the same datatype, then they are coerced to be of the same datatype. It is defined using the keyword `c()`.

```{r}
numbers = c(1,2,67)
```

The in-built R function `length()` is used to find the length of an atomic vector.

```{r}
length(numbers)
```

### Slicing the atomic vector

An atomic vector can be sliced using the indices of the elements within  `[]` brackets.

For example, consider the vector:

```{r}
vec<-1:40
```

Suppose, we wish to get the $3^{rd}$ element of the vector. We can get it using the index `3`:

```{r}
vec[3]
```

A sequence of consecutive elements can be sliced using the indices of the first element and the last element around the `:` operator. For example, let us slice elements from the $3^{rd}$ index to the $10^{th}$ element of the vector `vec`:

```{r}
vec[3:10]
```

We can slice elements at different indices by putting the indices in an atomic vector within the `[]` brackets. Let us slice the $4^{th}$, $7^{th}$, and $18^{th}$ elements of the vector `vec`:

```{r}
vec[c(4,7,18)]
```

We can slice consecutive elements, and non-consecutive elements simultaneously. Let us slice the elements from the $4^{th}$ index to the $9^{th}$ index and the $30^{th}$ and $36^{th}$ element.

```{r}
vec[c(4:9,30,36)]
```

### Removing elements from atomic vector

Elements can be removed from the vector using the negative sign within `[]` brackets.

Remove the 2nd element from the vector:

```{r}
vec<-1:5
vec[-2]
```

If multiple elements need to be removed, the indices of the elements to be removed can be given as an atomic vector.

Remove elements `2` to `6` and element 10 from the vector:
```{r}
vec<-1:20
vec[-c(2:6,10)]
```


**Example:** USA’s GDP per capita from 1960 to 2021 is given by the vector `G` in the code chunk below. The values are arranged in ascending order of the year, i.e., the first value is for 1960, the second value is for 1961, and so on. Store the years in which the GDP per capita of the US increased by more than 10%, in a vector.

```{r}
G = c(3007, 3067, 3244, 3375,3574, 3828, 4146, 4336, 4696, 5032,5234,5609,6094,6726,7226,7801,8592,9453,10565,11674,12575,13976,14434,15544,17121,18237,19071,20039,21417,22857,23889,24342,25419,26387,27695,28691,29968,31459,32854,34515,36330,37134,37998,39490,41725,44123,46302,48050,48570,47195,48651,50066,51784,53291,55124,56763,57867,59915,62805,65095,63028,69288)
```

```{r}
years<-c()
for(i in 1:(length(G)-1))
{
  diff = (G[i+1]-G[i])/G[i]
  if(diff>0.1){years<-c(years,1960+i)}
}
print(years)
```

### The `seq()` function

The `seq()` function is used to generate an atomic vector consisting of a sequence of integers with a constant gap. For example, the code below generates a sequence of integers starting from 20 upto 60 with gaps of 5.

```{r}
seq(20,60,5)
```

### The `rep()` function

The `rep()` function is used to repeat an object a fixed number of times.

```{r}
rep(4,10)
```

```{r}
rep(c(2,3),10)
```

### The `which()` function

The `which()` function is used to find the index of an object in an atomic vector. 

```{r}
vec<-c(8,3,4,7,9,7,5)
```

```{r}
which(vec==8)
```

The index of the maximum and minimum values can be found using `which.max()` and `which.min()` respectively.

```{r}
which.max(vec)
```

```{r}
which.min(vec)
```


### Practice exercise 1

Below is a vector consisting of responses to the question: “At what age do you think you will marry?” from students of the STAT303-1 Fall 2022 class.

```{r}
exp_marriage_age=c('24','30','28','29','30','27','26','28','30+','26','28','30','30','30','probably never','30','25','25','30','28','30+ ','30','25','28','28','25','25','27','28','30','30','35','26','28','27','27','30','25','30','26','32','27','26','27','26','28','37','28','28','28','35','28','27','28','26','28','26','30','27','30','28','25','26','28','35','29','27','27','30','24','25','29','27','33','30','30','25','26','30','32','26','30','30','I wont','25','27','27','25','27','27','32','26','25','never','28','33','28','35','25','30','29','30','31','28','28','30','40','30','28','30','27','by 30','28','27','28','30-35','35','30','30','never','30','35','28','31','30','27','33','32','27','27','26','N/A','25','26','29','28','34','26','24','28','30','120','25','33','27','28','32','30','26','30','30','28','27','27','27','27','27','27','28','30','30','30','28','30','28','30','30','28','28','30','27','30','28','25','never','69','28','28','33','30','28','28','26','30','26','27','30','25','Never','27','27','25')
```

#### Cleaning data
Remove the elements that are not integers - such as ‘probably never’, ‘30+’, etc. Convert the reamining elements to integer. What is the length of the new vector?

```{r}
new_vector<-as.integer(exp_marriage_age)
numeric_values<-new_vector[!is.na(new_vector)]
length(numeric_values)
```


#### Capping unreasonably high values
Cap the values greater than 80 to 80, in the clean vector obtained above. What is the mean age when people expect to marry in the new vector?

```{r}
numeric_values[numeric_values>80]<-80
mean(numeric_values)
```


#### People marrying at 30 or more
Determine the percentage of people who expect to marry at an age of 30 or more.
```{r}
sum(numeric_values>=30)/length(numeric_values)
```


## Matrix

Matrices are two-dimensional arrays. The in-built function `matrix()` is used to define a matrix. An atomic vector can be organized as a matrix by specifying the number of rows and columns.

For example, let us define a 2x3 matrix (2 rows and 3 columns) consisting of consecutive integers fro1 1 to 6.

```{r}
mat<-matrix(1:6,2,3)
mat
```

Note that the integers fill up column-wise in the matrix. If we wish to fill-up the matrix by row, we can use the `byrow` argument.

```{r}
mat<-matrix(1:6,2,3, byrow = TRUE)
mat
```

The functions `nrow()` and `ncol()` can be used to get the number of rows and columns of the matrix respectively.

```{r}
nrow(mat)
```

```{r}
ncol(mat)
```

Matrices can be sliced using the indices of row and column separated by a `,` in box brackets. Suppose we wish to get the element in the $2^{nd}$ row and $3^{rd}$ column of the matrix:

```{r}
mat[2,3]
```

For selecting all rows or columns of a matrix, the index for the row/column can be left blank. Suppose we wish to get all the elements of the $1^{st}$ of the matrix:

```{r}
mat[1,]
```

Row and columns of the matrix can be sliced using the `:` operator. Suppose we want to select a sub-matrix that has elements in the first two rows and columns 2 and 3 of the matrix `mat`:

```{r}
mat[1:2,2:3]
```

Element-wise arithmetic operations can be performed between 2 matrices of the same shape.

```{r}
mat1<-matrix(1:6,2,3)
mat2<-matrix(c(9,2,6,5,1,0),2,3)
mat1+mat2
```

```{r}
mat1-mat2
```

Suppose we need to sum up all the rows of the matrix. We can do it using a `for` loop as follows:

```{r}
row_sum<-c(0,0)
for(i in 1:nrow(mat))
{
  for(j in 1:ncol(mat))
  {
    row_sum[i]<-row_sum[i]+mat[i,j]
  }
}
row_sum
```

Observe that in the above `for` loop, elements of each row are added one at a time. We can add all the elements of a row simultaneously using the `sum()` function. This will reduce a `for` loop from the above code:

```{r}
row_sum<-c(0,0)
for(i in 1:nrow(mat))
{
    row_sum[i]<-sum(mat[i,])
}
row_sum
```

In the above code, we sum up all the elements of the row simultaneously. However, we still need to sum up the elements of each row one at a time.

### The `apply()` function

The `apply()` function can used to apply a function simultaneously on all rows or columns of a matrix. Thus, this function helps avoid a `for` loop to iterate over all the rows and columns of the matrix. This reduces the execution time of the code since operations are performed in-parallel, instead of one-at-a-time in a `for` loop.

Let us use the `apply()` function to sum up all the rows of the matrix `mat`.

```{r}
apply(mat,1,sum)
```

Let us compare the time taken to sum up rows of a matrix using a `for` loop with the time taken using the `apply()` function. 

```{r}
options(digits.secs = 6)
start.time <- Sys.time()
row_sum<-c(0,0)
for(i in 1:nrow(mat))
{
    row_sum[i]<-sum(mat[i,])
}
row_sum
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
```


```{r}
start.time <- Sys.time()
apply(mat,1,sum)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
```

Observe that the `apply()` function takes much lesser time to sum up all the rows of the matrix as compared to the `for` loop.

Recall the earlier example where we computed year's in which the increase in GDP per capita was more than 10%. Let us use matrices to solve the problem. We'll also compare the time it takes using a matrix with the time it takes using `for` loops.

```{r}
start.time <- Sys.time()

#Let the first column of the matrix be the GDP of all the years except 1960, and the second column be the GDP of all the years except 2021.
GDP_mat<-matrix(c(G[-1],G[-length(G)]),length(G)-1,2)

#The percent increase in GDP can be computed by performing computations using the 2 columns of the matrix
inc<-(GDP_mat[,1]-GDP_mat[,2])/GDP_mat[,2]
years<-1961:2021
years<-years[inc>0.1]
years
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
```


Without matrices, the time taken to perform the same computation is  measured with the code below.

```{r}
start.time <- Sys.time()
years<-c()
for(i in 1:(length(G)-1))
{
  diff = (G[i+1]-G[i])/G[i]
  if(diff>0.1){years<-c(years,1960+i)}
}
print(years)
#print(proc.time()[3]-start_time)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
```

Observe that matrices reduce the execution time of the code as computations are performed simultaneously, in contrast to a `for` loop where computations are performed one at a time.

Sometimes, the computations on rows / columns of a matrix are not straighforward and we may need to use the `apply()` function to apply a function on each row / column of a matrix.

**Example:** Find the maximum GDP per capita of the US in each of the 5 year periods starting from 1961-1965, and upto 2015-2020.

```{r}
GDP_5year<-matrix(G[-c(1,length(G))],12,5,byrow = TRUE)
GDP_max_5year<-apply(GDP_5year,1,max)
```

In the above code, we applied the in-built function `max` on all the rows. Sometimes, an in-built function may not be available for the computations to be performed. In such as case, we can write our own user-defined function within the `apply()` function. See the example below.

**Example:** Find the range (max-min) of GDP per capita of the US in each of the 5 year periods starting from 1961-1965, and upto 2015-2020.

```{r}
GDP_5year<-matrix(G[-c(1,length(G))],12,5,byrow = TRUE)
GDP_range_5year<-apply(GDP_5year,1,function(x) max(x)-min(x))
GDP_range_5year
```

In the code above we applied a user-defined function on each row of the matrix. However, if the function has multiple lines, it may be inconvenient to write the function within the `apply()` function. In that case, we can define the function outside the `apply()` function.

**Example:** Find the five year periods  starting from 1961-1965, and upto 2016-2020, during which the GDP per capita decreased as compared to the previous year.


```{r}

GDP_inc<-function(GDP_5yr)
{
  dec<-0
  for(i in 1:4)
  {
    if(GDP_5yr[i+1]<GDP_5yr[i]){dec<-1}
  }
  return(dec)
}

GDP_5year_mat<-matrix(G[-c(1,length(G))],12,5,byrow = TRUE)
years_inc_dec<-apply(GDP_5year_mat,1,GDP_inc)
five_year_periods<-seq(1960,2015,5)
print("Five year periods in which the GDP per capita decreased are those starting from the years:")
print(five_year_periods[years_inc_dec==1]+1)
```

The 5 year periods during which the GDP per capita decreased as compared to the previous year are 2006-2010, and 2016-2020.

### Practice exercise 2

Find the 5 year period in which the difference of the maximum GDP per capita and the minimum GDP per capita as a percentage of the minimum GDP per capita was the highest.

```{r}
five_year_periods[which.max(apply(GDP_5year_mat,1,function(x) (max(x)-min(x))/min(x)))]+1
```

During 1976-1980 the difference of the maximum GDP per capita and the minimum GDP per capita as a percentage of the minimum GDP per capita was the highest.

### Practice exercise 3

The object `countries` is an atomic vector consisting of country names. The object `coordinates` is a matrix consisting of the latitude-longitude pair of the capital city of the respective country. The order of countries in `countries` is the same as the order in which their capital city coordinates (latitude-longitude) appear in the matrix `coordinates`.

```{r}
countries<-c('Afghanistan', 'Aland Islands', 'Albania', 'Algeria', 'American Samoa', 'Andorra', 'Angola', 'Anguilla', 'Antarctica', 'Antigua and Barbuda', 'Argentina', 'Armenia', 'Aruba', 'Australia', 'Austria', 'Azerbaijan', 'Bahamas', 'Bahrain', 'Bangladesh', 'Barbados', 'Belarus', 'Belgium', 'Belize', 'Benin', 'Bermuda', 'Bhutan', 'Bolivia', 'Bosnia and Herzegovina', 'Botswana', 'Brazil', 'British Indian Ocean Territory', 'British Virgin Islands', 'Brunei Darussalam', 'Bulgaria', 'Burkina Faso', 'Burundi', 'Cambodia', 'Cameroon', 'Canada', 'Cape Verde', 'Cayman Islands', 'Central African Republic', 'Chad', 'Chile', 'China', 'Christmas Island', 'Cocos Islands', 'Colombia', 'Comoros', 'Cook Islands', 'Costa Rica', 'Cote dâ€™Ivoire', 'Croatia', 'Cuba', 'CuraÃƒÂ§ao', 'Cyprus', 'Czech Republic', 'Democratic Republic of the Congo', 'Denmark', 'Djibouti', 'Dominica', 'Dominican Republic', 'Ecuador', 'Egypt', 'El Salvador', 'Equatorial Guinea', 'Eritrea', 'Estonia', 'Ethiopia', 'Falkland Islands', 'Faroe Islands', 'Federated States of Micronesia', 'Fiji', 'Finland', 'France', 'French Polynesia', 'French Southern and Antarctic Lands', 'Gabon', 'Georgia', 'Germany', 'Ghana', 'Gibraltar', 'Greece', 'Greenland', 'Grenada', 'Guam', 'Guatemala', 'Guernsey', 'Guinea', 'Guinea-Bissau', 'Guyana', 'Haiti', 'Heard Island and McDonald Islands', 'Honduras', 'Hong Kong', 'Hungary', 'Iceland', 'India', 'Indonesia', 'Iran', 'Iraq', 'Ireland', 'Isle of Man', 'Israel', 'Italy', 'Jamaica', 'Japan', 'Jersey', 'Jordan', 'Kazakhstan', 'Kenya', 'Kiribati', 'Kosovo', 'Kuwait', 'Kyrgyzstan', 'Laos', 'Latvia', 'Lebanon', 'Lesotho', 'Liberia', 'Libya', 'Liechtenstein', 'Lithuania', 'Luxembourg', 'Macau', 'Macedonia', 'Madagascar', 'Malawi', 'Malaysia', 'Maldives', 'Mali', 'Malta', 'Marshall Islands', 'Mauritania', 'Mauritius', 'Mexico', 'Moldova', 'Monaco', 'Mongolia', 'Montenegro', 'Montserrat', 'Morocco', 'Mozambique', 'Myanmar', 'Namibia', 'Nauru', 'Nepal', 'Netherlands', 'New Caledonia', 'New Zealand', 'Nicaragua', 'Niger', 'Nigeria', 'Niue', 'Norfolk Island', 'North Korea', 'Northern Cyprus', 'Northern Mariana Islands', 'Norway', 'Oman', 'Pakistan', 'Palau', 'Palestine', 'Panama', 'Papua New Guinea', 'Paraguay', 'Peru', 'Philippines', 'Pitcairn Islands', 'Poland', 'Portugal', 'Puerto Rico', 'Qatar', 'Republic of Congo', 'Romania', 'Russia', 'Rwanda', 'Saint Barthelemy', 'Saint Helena', 'Saint Kitts and Nevis', 'Saint Lucia', 'Saint Martin', 'Saint Pierre and Miquelon', 'Saint Vincent and the Grenadines', 'Samoa', 'San Marino', 'Sao Tome and Principe', 'Saudi Arabia', 'Senegal', 'Serbia', 'Seychelles', 'Sierra Leone', 'Singapore', 'Sint Maarten', 'Slovakia', 'Slovenia', 'Solomon Islands', 'Somalia', 'Somaliland', 'South Africa', 'South Georgia and South Sandwich Islands', 'South Korea', 'South Sudan', 'Spain', 'Sri Lanka', 'Sudan', 'Suriname', 'Svalbard', 'Swaziland', 'Sweden', 'Switzerland', 'Syria', 'Taiwan', 'Tajikistan', 'Tanzania', 'Thailand', 'The Gambia', 'Timor-Leste', 'Togo', 'Tokelau', 'Tonga', 'Trinidad and Tobago', 'Tunisia', 'Turkey', 'Turkmenistan', 'Turks and Caicos Islands', 'Tuvalu', 'Uganda', 'Ukraine', 'United Arab Emirates', 'United Kingdom', 'United States', 'Uruguay', 'US Minor Outlying Islands', 'US Virgin Islands', 'Uzbekistan', 'Vanuatu', 'Vatican City', 'Venezuela', 'Vietnam', 'Wallis and Futuna', 'Western Sahara', 'Yemen', 'Zambia', 'Zimbabwe')

coord<-c(34.51666667,	60.116667,	41.31666667,	36.75,	-14.26666667,	42.5,	-8.833333333,	18.21666667,	0,	17.11666667,	-34.58333333,	40.16666667,	12.51666667,	-35.26666667,	48.2,	40.38333333,	25.08333333,	26.23333333,	23.71666667,	13.1,	53.9,	50.83333333,	17.25,	6.483333333,	32.28333333,	27.46666667,	-16.5,	43.86666667,	-24.63333333,	-15.78333333,	-7.3,	18.41666667,	4.883333333,	42.68333333,	12.36666667,	-3.366666667,	11.55,	3.866666667,	45.41666667,	14.91666667,	19.3,	4.366666667,	12.1,	-33.45,	39.91666667,	-10.41666667,	-12.16666667,	4.6,	-11.7,	-21.2,	9.933333333,	6.816666667,	45.8,	23.11666667,	12.1,	35.16666667,	50.08333333,	-4.316666667,	55.66666667,	11.58333333,	15.3,	18.46666667,	-0.216666667,	30.05,	13.7,	3.75,	15.33333333,	59.43333333,	9.033333333,	-51.7,	62,	6.916666667,	-18.13333333,	60.16666667,	48.86666667,	-17.53333333,	-49.35,	0.383333333,	41.68333333,	52.51666667,	5.55,	36.13333333,	37.98333333,	64.18333333,	12.05,	13.46666667,	14.61666667,	49.45,	9.5,	11.85,	6.8,	18.53333333,	0,	14.1,	0,	47.5,	64.15,	28.6,	-6.166666667,	35.7,	33.33333333,	53.31666667,	54.15,	31.76666667,	41.9,	18,	35.68333333,	49.18333333,	31.95,	51.16666667,	-1.283333333,	-0.883333333,	42.66666667,	29.36666667,	42.86666667,	17.96666667,	56.95,	33.86666667,	-29.31666667,	6.3,	32.88333333,	47.13333333,	54.68333333,	49.6,	0,	42,	-18.91666667,	-13.96666667,	3.166666667,	4.166666667,	12.65,	35.88333333,	7.1,	18.06666667,	-20.15,	19.43333333,	47,	43.73333333,	47.91666667,	42.43333333,	16.7,	34.01666667,	-25.95,	16.8,	-22.56666667,	-0.5477,	27.71666667,	52.35,	-22.26666667,	-41.3,	12.13333333,	13.51666667,	9.083333333,	-19.01666667,	-29.05,	39.01666667,	35.183333,	15.2,	59.91666667,	23.61666667,	33.68333333,	7.483333333,	31.76666667,	8.966666667,	-9.45,	-25.26666667,	-12.05,	14.6,	-25.06666667,	52.25,	38.71666667,	18.46666667,	25.28333333,	-4.25,	44.43333333,	55.75,	-1.95,	17.88333333,	-15.93333333,	17.3,	14,	18.0731,	46.76666667,	13.13333333,	-13.81666667,	43.93333333,	0.333333333,	24.65,	14.73333333,	44.83333333,	-4.616666667,	8.483333333,	1.283333333,	18.01666667,	48.15,	46.05,	-9.433333333,	2.066666667,	9.55,	-25.7,	-54.283333,	37.55,	4.85,	40.4,	6.916666667,	15.6,	5.833333333,	78.21666667,	-26.31666667,	59.33333333,	46.91666667,	33.5,	25.03333333,	38.55,	-6.8,	13.75,	13.45,	-8.583333333,	6.116666667,	-9.166667,	-21.13333333,	10.65,	36.8,	39.93333333,	37.95,	21.46666667,	-8.516666667,	0.316666667,	50.43333333,	24.46666667,	51.5,	38.883333,	-34.85,	38.883333,	18.35,	41.31666667,	-17.73333333,	41.9,	10.48333333,	21.03333333,	-13.95,	27.153611,	15.35,	-15.41666667,	-17.81666667,	69.183333,	19.9,	19.816667,	3.05,	-170.7,	1.516667,	13.216667,	-63.05,	0,	-61.85,	-58.666667,	44.5,	-70.033333,	149.133333,	16.366667,	49.866667,	-77.35,	50.566667,	90.4,	-59.616667,	27.566667,	4.333333,	-88.766667,	2.616667,	-64.783333,	89.633333,	-68.15,	18.416667,	25.9,	-47.916667,	72.4,	-64.616667,	114.933333,	23.316667,	-1.516667,	29.35,	104.916667,	11.516667,	-75.7,	-23.516667,	-81.383333,	18.583333,	15.033333,	-70.666667,	116.383333,	105.716667,	96.833333,	-74.083333,	43.233333,	-159.766667,	-84.083333,	-5.266667,	16,	-82.35,	-68.916667,	33.366667,	14.466667,	15.3,	12.583333,	43.15,	-61.4,	-69.9,	-78.5,	31.25,	-89.2,	8.783333,	38.933333,	24.716667,	38.7,	-57.85,	-6.766667,	158.15,	178.416667,	24.933333,	2.333333,	-149.566667,	70.216667,	9.45,	44.833333,	13.4,	-0.216667,	-5.35,	23.733333,	-51.75,	-61.75,	144.733333,	-90.516667,	-2.533333,	-13.7,	-15.583333,	-58.15,	-72.333333,	0,	-87.216667,	0,	19.083333,	-21.95,	77.2,	106.816667,	51.416667,	44.4,	-6.233333,	-4.483333,	35.233333,	12.483333,	-76.8,	139.75,	-2.1,	35.933333,	71.416667,	36.816667,	169.533333,	21.166667,	47.966667,	74.6,	102.6,	24.1,	35.5,	27.483333,	-10.8,	13.166667,	9.516667,	25.316667,	6.116667,	0,	21.433333,	47.516667,	33.783333,	101.7,	73.5,	-8,	14.5,	171.383333,	-15.966667,	57.483333,	-99.133333,	28.85,	7.416667,	106.916667,	19.266667,	-62.216667,	-6.816667,	32.583333,	96.15,	17.083333,	166.920867,	85.316667,	4.916667,	166.45,	174.783333,	-86.25,	2.116667,	7.533333,	-169.916667,	167.966667,	125.75,	33.366667,	145.75,	10.75,	58.583333,	73.05,	134.633333,	35.233333,	-79.533333,	147.183333,	-57.666667,	-77.05,	120.966667,	-130.083333,	21,	-9.133333,	-66.116667,	51.533333,	15.283333,	26.1,	37.6,	30.05,	-62.85,	-5.716667,	-62.716667,	-61,	-63.0822,	-56.183333,	-61.216667,	-171.766667,	12.416667,	6.733333,	46.7,	-17.633333,	20.5,	55.45,	-13.233333,	103.85,	-63.033333,	17.116667,	14.516667,	159.95,	45.333333,	44.05,	28.216667,	-36.5,	126.983333,	31.616667,	-3.683333,	79.833333,	32.533333,	-55.166667,	15.633333,	31.133333,	18.05,	7.466667,	36.3,	121.516667,	68.766667,	39.283333,	100.516667,	-16.566667,	125.6,	1.216667,	-171.833333,	-175.2,	-61.516667,	10.183333,	32.866667,	58.383333,	-71.133333,	179.216667,	32.55,	30.516667,	54.366667,	-0.083333,	-77,	-56.166667,	-77,	-64.933333,	69.25,	168.316667,	12.45,	-66.866667,	105.85,	-171.933333,	-13.203333,	44.2,	28.283333,	31.033333
)
coordinates<-matrix(coord,245,2)
```

#### Country with capital closest to DC
Print the name and coordinates of the country with the capital city closest to the US capital - Washington DC. 

Note that:

1. The *Country Name* for US is given as *United States* in the data.
2. The 'closeness' of capital cities from the US capital is based on the Euclidean distance of their coordinates to those of the US capital.

```{r}
#| eval: false
#| echo: false

dc_coord<-coordinates[which(countries=='United States'),]
diff = coordinates-matrix(c(rep(dc_coord,245)),245,2,byrow = TRUE)
distances = apply(diff**2,1,sum)
distances[distances==0]<-99999
closest_country<-countries[which.min(distances)]
print(closest_country)
coord_close<-coordinates[which.min(distances),]
```


#### Top 10 countries closest to DC

1. Print the names of the countries of the top 10 capital cities closest to the US capital - Washington DC. 

2. Create and print a matrix containing the coordinates of the top 10 capital cities closest to Washington DC.

```{r}
#| eval: false
#| echo: false
cc<-c()
for(i in 1:10)
{
  distances[which.min(distances)]<-99999
  cc<-c(cc,countries[which.min(distances)])
  coord_close<-rbind(coord_close,coordinates[which.min(distances),])
}
cc
```
